
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>WebXR ES Module Viewer</title>
  <style>
    body { margin: 0; font-family: Arial, sans-serif; background: #111; overflow: hidden; }
    canvas { display: block; }
    #ui, #annotations, #welcome {
      position: absolute;
      z-index: 10;
      background: rgba(255,255,255,0.95);
      padding: 10px;
      border-radius: 8px;
      font-size: 14px;
    }
    #ui { top: 10px; left: 10px; }
    #annotations { top: 10px; right: 10px; max-height: 300px; overflow-y: auto; max-width: 250px; }
    #welcome {
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      display: none;
    }
    #welcome input, #welcome button {
      margin-top: 10px;
    }
    .btn { background: #007bff; color: white; padding: 5px 10px; border: none; border-radius: 5px; cursor: pointer; }
  </style>
</head>
<body>

<div id="welcome">
  <h2>WebXR Collaboration Tool</h2>
  <p>Upload your 3D model (.glb, .gltf, .fbx, .obj) to begin.</p>
  <input type="file" id="upload" accept=".glb,.gltf,.fbx,.obj" />
  <br/>
  <button id="start" class="btn" disabled>Start</button>
</div>

<div id="ui" style="display:none;">
  <strong>Instructions:</strong><br/>
  üñ± Drag = Rotate<br/>
  üîç Scroll = Zoom<br/>
  üñ± Right-click = Add annotation
</div>

<div id="annotations" style="display:none;">
  <strong>Annotations:</strong>
  <div id="list">None yet</div>
  <button onclick="clearAll()" class="btn">Clear All</button>
</div>

<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
  console.log("Three.js loaded:", THREE.REVISION);
  import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
  import { FBXLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/FBXLoader.js';
  import { OBJLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/OBJLoader.js';

  let scene, camera, renderer, annotationObjects = [], annotations = {}, modelFile;

  const upload = document.getElementById('upload');
  const startBtn = document.getElementById('start');
  const list = document.getElementById('list');

  upload.addEventListener('change', e => {
    modelFile = e.target.files[0];
    startBtn.disabled = !modelFile;
  });

  startBtn.addEventListener('click', () => {
    document.getElementById('welcome').style.display = 'none';
    document.getElementById('ui').style.display = 'block';
    document.getElementById('annotations').style.display = 'block';
    init();
  });

  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202040);
    camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0, 2, 5);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(5, 10, 7.5);
    scene.add(light);

    loadModel(modelFile);
    setupControls();
    animate();
  }

  function loadModel(file) {
    const ext = file.name.split('.').pop().toLowerCase();
    const reader = new FileReader();
    reader.onload = e => {
      const buffer = e.target.result;
      if (ext === 'glb' || ext === 'gltf') {
        const loader = new GLTFLoader();
        loader.parse(buffer, '', gltf => addToScene(gltf.scene));
      } else if (ext === 'fbx') {
        const loader = new FBXLoader();
        addToScene(loader.parse(buffer));
      } else if (ext === 'obj') {
        const loader = new OBJLoader();
        const text = new TextDecoder().decode(buffer);
        addToScene(loader.parse(text));
      }
    };
    reader.readAsArrayBuffer(file);
  }

  function addToScene(model) {
    model.traverse(c => {
      if (c.isMesh) {
        c.userData.annotatable = true;
        annotationObjects.push(c);
      }
    });
    scene.add(model);
  }

  function setupControls() {
    let isDragging = false, mouse = {x: 0, y: 0}, theta = 0, phi = Math.PI/4, radius = 5;

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    document.addEventListener('contextmenu', e => e.preventDefault());
    document.addEventListener('mousedown', e => {
      if (e.button === 0) isDragging = true;
      mouse = {x: e.clientX, y: e.clientY};
    });
    document.addEventListener('mouseup', e => {
      if (e.button === 2) handleAnnotation(e);
      isDragging = false;
    });
    document.addEventListener('mousemove', e => {
      if (!isDragging) return;
      const dx = e.clientX - mouse.x, dy = e.clientY - mouse.y;
      theta -= dx * 0.01;
      phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi + dy * 0.01));
      updateCamera();
      mouse = {x: e.clientX, y: e.clientY};
    });
    document.addEventListener('wheel', e => {
      radius = Math.max(2, Math.min(15, radius + e.deltaY * 0.01));
      updateCamera();
    });

    function updateCamera() {
      camera.position.x = radius * Math.sin(phi) * Math.cos(theta);
      camera.position.y = radius * Math.cos(phi);
      camera.position.z = radius * Math.sin(phi) * Math.sin(theta);
      camera.lookAt(0, 1, 0);
    }

    updateCamera();
  }

  function handleAnnotation(e) {
    const rect = renderer.domElement.getBoundingClientRect();
    const mouse = new THREE.Vector2(
      ((e.clientX - rect.left) / rect.width) * 2 - 1,
      -((e.clientY - rect.top) / rect.height) * 2 + 1
    );
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(annotationObjects, true);
    if (intersects.length > 0) {
      const point = intersects[0].point;
      const id = Date.now().toString();
      annotations[id] = { x: point.x, y: point.y, z: point.z };
      updateAnnotations();
    }
  }

  function updateAnnotations() {
    Object.values(annotations).forEach(a => {
      const geo = new THREE.SphereGeometry(0.06), mat = new THREE.MeshBasicMaterial({ color: 0xff3333 });
      const dot = new THREE.Mesh(geo, mat);
      dot.position.set(a.x, a.y, a.z);
      scene.add(dot);
    });
    list.innerHTML = Object.keys(annotations).map((k, i) => `<div>#${i + 1} @ ${k}</div>`).join('');
  }

  window.clearAll = () => {
    annotations = {};
    list.innerHTML = "None yet";
    scene.children = scene.children.filter(c => !c.geometry?.type?.includes('Sphere'));
  }

  document.getElementById('welcome').style.display = 'block';
</script>

</body>
</html>
