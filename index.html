
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebXR ImportMap Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { margin: 0; font-family: sans-serif; background: #111; overflow: hidden; }
    canvas { display: block; }
    #welcome, #ui, #annotations {
      position: absolute; z-index: 10; background: rgba(255,255,255,0.95); padding: 10px; border-radius: 8px;
    }
    #welcome { top: 20%; left: 50%; transform: translateX(-50%); text-align: center; }
    #ui { top: 10px; left: 10px; }
    #annotations { top: 10px; right: 10px; max-height: 300px; overflow-y: auto; max-width: 250px; }
    .btn { margin-top: 10px; background: #007bff; color: white; padding: 5px 10px; border: none; border-radius: 5px; cursor: pointer; }
  </style>
</head>
<body>

<div id="welcome">
  <h2>WebXR Collaboration Tool</h2>
  <p>Upload a .glb, .gltf, .fbx or .obj file</p>
  <input type="file" id="upload" accept=".glb,.gltf,.fbx,.obj" />
  <br/>
  <button id="start" class="btn" disabled>Start</button>
</div>

<div id="ui" style="display:none;">
  <strong>Instructions:</strong><br/>
  üñ± Drag = Rotate<br/>
  üîç Scroll = Zoom<br/>
  üñ± Right-click = Add annotation
</div>

<div id="annotations" style="display:none;">
  <strong>Annotations</strong>
  <div id="list">None</div>
  <button onclick="clearAll()" class="btn">Clear All</button>
</div>

<!-- Import Map for ES Module Imports -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/examples/jsm/loaders/GLTFLoader.js": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js",
    "three/examples/jsm/loaders/FBXLoader.js": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/FBXLoader.js",
    "three/examples/jsm/loaders/OBJLoader.js": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/OBJLoader.js"
  }
}
</script>

<script type="module">
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
  import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js';
  import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js';

  let scene, camera, renderer, annotationObjects = [], annotations = {}, modelFile;

  const $ = id => document.getElementById(id);
  const upload = $('upload'), startBtn = $('start'), list = $('list');

  upload.addEventListener('change', e => {
    modelFile = e.target.files[0];
    startBtn.disabled = !modelFile;
  });

  startBtn.addEventListener('click', () => {
    $('welcome').style.display = 'none';
    $('ui').style.display = 'block';
    $('annotations').style.display = 'block';
    init();
  });

  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202040);
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 2, 5);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(5, 10, 7.5);
    scene.add(light);
    loadModel(modelFile);
    setupControls();
    animate();
  }

  function loadModel(file) {
    const ext = file.name.split('.').pop().toLowerCase();
    const reader = new FileReader();
    reader.onload = e => {
      const buffer = e.target.result;
      if (ext === 'glb' || ext === 'gltf') {
        const loader = new GLTFLoader();
        loader.parse(buffer, '', gltf => addToScene(gltf.scene));
      } else if (ext === 'fbx') {
        const loader = new FBXLoader();
        addToScene(loader.parse(buffer));
      } else if (ext === 'obj') {
        const loader = new OBJLoader();
        const text = new TextDecoder().decode(buffer);
        addToScene(loader.parse(text));
      }
    };
    reader.readAsArrayBuffer(file);
  }

  function addToScene(model) {
    model.traverse(c => {
      if (c.isMesh) {
        c.userData.annotatable = true;
        annotationObjects.push(c);
      }
    });
    scene.add(model);
  }

  function setupControls() {
    let isDragging = false, mouse = {x: 0, y: 0}, theta = 0, phi = Math.PI/4, radius = 5;

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    document.addEventListener('contextmenu', e => e.preventDefault());
    document.addEventListener('mousedown', e => {
      if (e.button === 0) isDragging = true;
      mouse = {x: e.clientX, y: e.clientY};
    });
    document.addEventListener('mouseup', e => {
      if (e.button === 2) handleAnnotation(e);
      isDragging = false;
    });
    document.addEventListener('mousemove', e => {
      if (!isDragging) return;
      const dx = e.clientX - mouse.x, dy = e.clientY - mouse.y;
      theta -= dx * 0.01;
      phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi + dy * 0.01));
      updateCamera();
      mouse = {x: e.clientX, y: e.clientY};
    });
    document.addEventListener('wheel', e => {
      radius = Math.max(2, Math.min(15, radius + e.deltaY * 0.01));
      updateCamera();
    });

    function updateCamera() {
      camera.position.x = radius * Math.sin(phi) * Math.cos(theta);
      camera.position.y = radius * Math.cos(phi);
      camera.position.z = radius * Math.sin(phi) * Math.sin(theta);
      camera.lookAt(0, 1, 0);
    }

    updateCamera();
  }

  function handleAnnotation(e) {
    const rect = renderer.domElement.getBoundingClientRect();
    const mouse = new THREE.Vector2(
      ((e.clientX - rect.left) / rect.width) * 2 - 1,
      -((e.clientY - rect.top) / rect.height) * 2 + 1
    );
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObjects(annotationObjects, true);
    if (hits.length > 0) {
      const point = hits[0].point;
      const id = Date.now().toString();
      annotations[id] = { x: point.x, y: point.y, z: point.z };
      updateAnnotations();
    }
  }

  function updateAnnotations() {
    Object.values(annotations).forEach(a => {
      const dot = new THREE.Mesh(
        new THREE.SphereGeometry(0.06),
        new THREE.MeshBasicMaterial({ color: 0xff3333 })
      );
      dot.position.set(a.x, a.y, a.z);
      scene.add(dot);
    });
    list.innerHTML = Object.keys(annotations).map((k, i) => `<div>#${i + 1} @ ${k}</div>`).join('');
  }

  window.clearAll = () => {
    annotations = {};
    list.innerHTML = "None";
    scene.children = scene.children.filter(c => !c.geometry?.type?.includes('Sphere'));
  }

  document.getElementById('welcome').style.display = 'block';
</script>

</body>
</html>
