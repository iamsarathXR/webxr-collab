<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WebXR Collaboration Tool</title>
  <style>
    body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: Arial, sans-serif; }
    canvas { display: block; cursor: grab; }
    canvas:active { cursor: grabbing; }
    #ui, #annotations-panel { display: none; } /* Hide DOM UI in immersive mode */
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 18px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="loading">Initializing 3D Scene...</div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const mockDB = {
      annotations: {},
      listeners: [],
      addAnnotation(id, data) {
        this.annotations[id] = data;
        this.notifyListeners();
      },
      removeAnnotation(id) {
        delete this.annotations[id];
        this.notifyListeners();
      },
      updateAnnotation(id, data) {
        if (this.annotations[id]) {
          this.annotations[id] = { ...this.annotations[id], ...data };
          this.notifyListeners();
        }
      },
      onUpdate(callback) {
        this.listeners.push(callback);
        callback(this.annotations);
      },
      notifyListeners() {
        this.listeners.forEach(cb => cb(this.annotations));
      }
    };

    let scene, camera, renderer;
    let annotationObjects = [];
    let cameraRadius = 8;
    let cameraTheta = 0;
    let cameraPhi = Math.PI / 4;

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x222244);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      updateCameraPosition();

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      setupLighting();
      createObjects();
      setupEventListeners();
      animate();

      document.getElementById('loading').style.display = 'none';
    }

    function setupLighting() {
      scene.add(new THREE.AmbientLight(0x404040, 0.4));
      const light = new THREE.DirectionalLight(0xffffff, 0.8);
      light.position.set(10, 10, 5);
      light.castShadow = true;
      scene.add(light);
    }

    function createObjects() {
      const cube = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), new THREE.MeshLambertMaterial({ color: 0xff6b6b }));
      cube.position.set(0, 1, 0);
      cube.userData.annotatable = true;
      scene.add(cube);
      annotationObjects.push(cube);

      for (let i = 0; i < 6; i++) {
        const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshLambertMaterial({ color: new THREE.Color().setHSL(i / 6, 0.8, 0.6) }));
        const angle = (i / 6) * Math.PI * 2;
        sphere.position.set(Math.cos(angle) * 3, 1 + Math.sin(i) * 0.5, Math.sin(angle) * 3);
        sphere.userData.annotatable = true;
        scene.add(sphere);
        annotationObjects.push(sphere);
      }

      const ground = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), new THREE.MeshLambertMaterial({ color: 0x333366 }));
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);
    }

    function setupEventListeners() {
      renderer.domElement.addEventListener('click', handleClick);
      mockDB.onUpdate(updateAnnotationDisplay);
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function handleClick(e) {
      const rect = renderer.domElement.getBoundingClientRect();
      const mouse = new THREE.Vector2(
        ((e.clientX - rect.left) / rect.width) * 2 - 1,
        -((e.clientY - rect.top) / rect.height) * 2 + 1
      );
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(annotationObjects, true);
      if (intersects.length > 0) {
        const point = intersects[0].point;
        const id = Date.now().toString();
        mockDB.addAnnotation(id, { x: point.x, y: point.y, z: point.z, comment: `Note ${Object.keys(mockDB.annotations).length + 1}` });
      }
    }

    function updateAnnotationDisplay(annotations) {
      scene.traverse(obj => {
        if (obj.userData.isAnnotation) scene.remove(obj);
      });
      Object.entries(annotations).forEach(([id, ann]) => {
        const dot = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 16), new THREE.MeshBasicMaterial({ color: 0xff3333 }));
        dot.position.set(ann.x, ann.y, ann.z);
        dot.userData.isAnnotation = true;
        scene.add(dot);

        const text = create3DTextLabel(ann.comment, dot.position);
        text.userData.isAnnotation = true;
        scene.add(text);
      });
    }

    function create3DTextLabel(text, position) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#000';
      ctx.font = '24px Arial';
      ctx.fillText(text, 10, 40);

      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(1.5, 0.4, 1);
      sprite.position.set(position.x, position.y + 0.3, position.z);
      return sprite;
    }

    function updateCameraPosition() {
      camera.position.x = cameraRadius * Math.sin(cameraPhi) * Math.cos(cameraTheta);
      camera.position.y = cameraRadius * Math.cos(cameraPhi);
      camera.position.z = cameraRadius * Math.sin(cameraPhi) * Math.sin(cameraTheta);
      camera.lookAt(0, 1, 0);
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    window.addEventListener('load', init);
  </script>
</body>
</html>
